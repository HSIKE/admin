# Host: 127.0.0.1  (Version 5.0.87-community-nt)
# Date: 2019-02-20 17:35:22
# Generator: MySQL-Front 6.1  (Build 1.26)


#
# Structure for table "articles"
#

DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `Id` int(11) NOT NULL auto_increment,
  `type` varchar(255) default NULL COMMENT '文章类型（推荐？）',
  `pid` varchar(255) default NULL COMMENT '所属分类(导航)',
  `author` varchar(255) default NULL COMMENT '作者',
  `title` varchar(255) default NULL COMMENT '文章标题',
  `description` varchar(10000) default '' COMMENT '文章描述',
  `tags` varchar(255) default NULL COMMENT '文章标签',
  `thumbnail` varchar(255) default NULL COMMENT '缩略图',
  `content` longtext COMMENT '文章内容',
  `time` timestamp NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP COMMENT '最后修改时间',
  PRIMARY KEY  (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COMMENT='文章';

#
# Data for table "articles"
#

INSERT INTO `articles` VALUES (1,'普通','JavaScript','HSIKE','JavaScript中的简单数据类型（基本数据类型）','JS中的数据类型分为2种：基本数据类型 和 引用数据类型。而在《JavaScript高级程序设计 第三版》中，将其分为 简单数据类型（基本数据类型） 和 复杂数据类型。其中，简单数据类型包括：Undefined、Null、Boolean、Number 和 String（ES6新增了Symbol）。','数据类型','test ava','<blockquote><strong>简单数据类型</strong></blockquote><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">1、Undefined类型：只有一个值——undefined，在声明变量时 未对其进行初始化，这个变量的值即为 undefined</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">var und；\nconsole.log(und);// undefined \n</pre><p><br></p><p>2、Null类型：只有一个值——null，空</p><pre class=\"ql-syntax\" spellcheck=\"false\">var nul=null;\nconsole.log(typeof nul);// \"object\"\n</pre><p>\t<span class=\"ql-font-serif\">在逻辑上，null 为一个空对象指针，表示一个空的对象引用。故在使用 \"typeof\" 操作符进行数据类型检测时返回值为 \"object\"</span></p><p><br></p><p>3、Boolean类型：布尔值，包含2个值：true 和 false，表示逻辑上的 真 或 假</p><pre class=\"ql-syntax\" spellcheck=\"false\">var tru=true;\nvar fal=false;\n</pre><p><br></p><p>4、Number类型：数值，包含：整数int、浮点数float、非数值NaN</p><p>\t①整数：ES中定义的数值字面量包含 十进制整数、八进制整数 和 十六进制整数</p><pre class=\"ql-syntax\" spellcheck=\"false\">var num1=10; // 十进制的整数10\n\n// 八进制整数的第一位数字必须是 0\nvar num2=020; // 八进制的16\nvar num3=08; // 无效的八进制数值，被解析为十进制的8\n\n// 十六进制的前2位必须是 0x\nvar num4=0xF; // 十六进制的15\nvar num5=0xf; // 十六进制的15 十六进制数字中的字母（a-f）不区分大小写\n</pre><p><br></p><p>\t②浮点数：即小数</p><pre class=\"ql-syntax\" spellcheck=\"false\">var flo=1.0001;\n</pre><p><br></p><p>\t③非数值：NaN，\"Not a Number\" 的缩写，NaN是一个特殊值，用于表示一个本来要返回数值的操作数为返回数值的情况（防止抛出错误）。它有以下2个特点：</p><p>a、任何涉及 NaN 的操作都会返回 NaN</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(NaN + 1); // NaN\n</pre><p>b、NaN 不与任何值相等，包括 NaN 本身</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(NaN == NaN); // false\n</pre><p>\t<span class=\"ql-font-serif\">为此，JS中定义了 isNaN() 函数，用来检测传入其中的参数是否为 \"非数值\"，并返回 true/false</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(isNaN(1)); // false\nconsole.log(isNan(\'str\')); // true\n</pre><p><br></p><p>\t<span class=\"ql-font-serif\">值得注意的是，当向 isNaN() 函数中传入 Boolean 的 true 或 false 后</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(isNaN(true)); // false\nconsole.log(isNaN(false)); // false\n</pre><p>\t<span class=\"ql-font-serif\">2个输出结果都为 false，这是因为 Boolean 值的 true 和 false 可以被转换为数字的 1 和 0，而其他不能被转换为数字的值则被视为 NaN。</span></p><p><br></p><p>JS中还提供了3个函数，把非数值转换为数值：Number()（转换字符串时较为复杂且不够合理，一般不会使用）、parseInt()、parseFloat()</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(parseInt(true)); // 1\nconsole.log(parseInt(\'true123\')); // NaN\nconsole.log(parseInt(\'123true321\')); // 123 只转换字符串中开头的数字部分\nconsole.log(parseInt(\'0xf\')); // 15\nconsole.log(parseInt(\'070\')); // 70\nconsole.log(parseInt(\'070\',8)); // 56  第二个参数表示将传入的数字作为八进制数值进行解析\n\n// parseFloat()同理\nconsole.log(parseFloat(\'1.23.123\')); // 1.23\n</pre><p><br></p><p>5、String类型：字符串，由 0 或 多个 Unicode 字符组成的字符序列</p><pre class=\"ql-syntax\" spellcheck=\"false\">var str=\'this is a string\'; // 可以使用单引号也可以使用双引号\n</pre><p>\t<span class=\"ql-font-serif\">JS中的字符串是不可变的，一旦创建就无法修改，每次修改变量中保存的字符串类型值时，都是先销毁原来的字符串，然后用一个包含新值的字符串填充该变量。</span></p><p><br></p><blockquote><strong>简单数据类型特点</strong></blockquote><p>与 复杂数据类型（引用数据类型）不同的是，<span style=\"background-color: rgb(255, 255, 255);\">JS中所有简单数据类型值的引用都是独一无二的，</span>当把变量 <span style=\"background-color: rgb(255, 255, 255);\">a </span>的简单数据类型值赋予 变量b 时，变量b 中保存的实际是 变量a 的一个副本，修改其中某个变量的值并不会影响另一个。</p><pre class=\"ql-syntax\" spellcheck=\"false\">var a=\'variable\';\nvar b=a; // \'variable\'\na=\'value changed\';\nconsole.log(b); // \'variable\'\n</pre>','2019-02-20 00:15:59'),(2,'普通','JavaScript','HSIKE','JavaScript中的数组（Array）','数组（Array）是JavaScript中极为常用的一种数据类型，其本质就是一组数据的集合。在JS中，数组有以下特点：1、数组定义时无需指定数据类型；2、数组定义时可以无需指定数组长度；3、数组可以存储任何数据类型的数据。','数组、数组方法','','<blockquote><strong>数组的创建</strong></blockquote><p><br></p><p>1、使用 Array 构造函数 <u>指定值</u> 创建：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var arr1=new Array(\'1\', \'2\');// 将创建一个包含 \'1\'、\'2\' 2个元素的数组 \n</pre><p>2、创建 <u>指定长度</u> 数组：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var arr2=new Array(2);// 将创建一个长度为2的数组，但2个元素都为 undefined\n</pre><p>3、字面量形式创建：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var arr3=[\'1\',\'2\'];// 将创建一个包含 \'1\'、2\' 2个元素的数组 \n</pre><p>\t<span class=\"ql-font-serif\">以上3种创建数组方式中，推荐使用第3种——字面量形式创建。</span></p><p><br></p><p>\t注意：在JS中，每创建一个数组都会在内存中生成一个 <u>独一无二的地址</u> 对应所创建的数组；因此，即使2个数组中包含的元素完全一样，这2个数组也不全等（===）。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr1===arr3);// false\n</pre><p><br></p><blockquote><strong>数组的属性</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">数组的常用属性有：length，表示数组的 长度</em></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.length);// \n</pre><p>此外，还有数组的 索引，表示数据在 数组中所处的位置，可以此访问数组中指定位置的元素：</p><pre class=\"ql-syntax\" spellcheck=\"false\">for (var index=0;index&lt;arr3.length;index++) console.log(\'index:\',index,\'value:\',arr[index]);\n// 将输出：\n// 0:\'1\'\n// 1:\'2\'\n</pre><p>\t<span class=\"ql-font-serif\">数组的索引是从 0 开始的，而不是 1，表示数组的 第一个 元素。</span></p><p><br></p><blockquote><strong>数组的常用方法</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">包括：concat()、join()、pop()、push()、shift()、unshift、slice()、splice()等</em></p><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">1、contact()：</span><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">连接多个数组或在数组末尾加入新的元素，并返回拼接后的结果。不会修改原数组。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.concat(\'3\',[\'4\']);// [\'1\',\'2\',\'3\',\'4\']\nconsole.log(arr3);// [\'1\',\'2\']\n</pre><p><br></p><p>2、join(seperator)：将数组内元素拼接成字符串，并以传入的分隔符seperator 隔开，seperator可选，缺省时以 \",\" 隔开。不会修改原数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.join(\'||\'));// \"1||2\"\n</pre><p><br></p><p>3、pop()：<span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">删除并返回数组的最后一个元素。修改原数组。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.pop()); // \'2\'\nconsole.log(arr3); // \'1\'\n</pre><p><br></p><p>4、push()：向数组末尾加入一个或多个元素，并返回操作后的数组长度。修改原数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.push(\'3\',\'4\');// 3\nconsole.log(arr3);// [\'1\',\'3\',\'4\']\n</pre><p>\t<span class=\"ql-font-serif\">注意：如果使用push()方法将一个数组加入到另一个数组的末尾，并不会像concat()方法一样将目标数组进行解构后将其内元素一一插入原数组末尾，而是直接将目标数组作为元素插入原数组中。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">arr3.push(\'5\',[\'6\']);\nconsole.log(arr3);// [\'1\',\'3\',\'4\',\'5\',[\'6\']]\n</pre><p><br></p><p>5、shift()：删除并返回数组的第一个元素。修改原数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.shift());// \'1\'\nconsole.log(arr3);// [\'3\',\'4\',\'5\',[\'6\']]\n</pre><p><br></p><p>6、unshift()：在数组头部开始插入一个或多个元素，并返回操作后的数组长度。修改原数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.unshift([\'0\']));// 5\nconsole.log(arr3);// [\'0\',\'3\',\'4\',\'5\',[\'6\']]\n</pre><p><br></p><p>7、slice(start,end)：截取并返回数组中从索引为start（包含）和 索引为 end（不包含）之间的所有元素组成的数组。不修改原数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.slice(1,3));// [\'3\',\'4\']\n</pre><p>\t<span class=\"ql-font-serif\">其中，end为可选，若缺省则表示截取至数组的最后一个元素（包含）；start可以是负数，表示从数组的末尾开始的第 n 个位置开始截取（-1表示数组最后一个元素）。</span></p><p><br></p><p>8、splice(start, count, newEle)：删除并返回数组中从索引为start的元素开始、数量为count的元素，并插入一个或多个新元素。修改原数组</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr3.splice(2,3,\'7\')); // [\'4\',\'5\',[\'6\']]\ncconsole.log(arr3);// [\'0\',\'3\',\'7\']\n</pre><p>\t<span class=\"ql-font-serif\">其中，newEle为可选，表示只删除数组中的某个片段，而不插入新的元素；start可以为负，表示从数组的末尾开始；count可以为0，表示不删除原数组中的元素，而在 </span><u class=\"ql-font-serif\" style=\"color: rgb(92, 0, 0);\">指定位置后</u><span class=\"ql-font-serif\"> 插入新的元素。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">arr3.splice(2,1); // 删除arr3中索引为2的元素，即 \'7\'\narr3.splice(0,0,\'8\'); // [\'0\',\'8\',\'3\']\n</pre><p><br></p><p>除了此以外，数组还有：reverse()--数组元素顺序颠倒、sort()--数组排序、toString()--转换为字符串等方法。</p>','2019-02-20 14:29:03'),(3,'推荐','CSS','HSIKE','CSS样式权重、选择器优先级的比较','CSS：Cascading Style Sheets 重叠样式表，其包含三大特征：\n1、继承，即子类元素继承父类元素的样式；\n2、优先级，不同类别样式的权重比较，优先级较高的样式覆盖优先级低的；\n3、重叠，当权重相同时，后者覆盖前者（重叠）的样式。这里主要介绍CSS样式优先级中 选择器的优先级。','样式、选择器','','<p><span class=\"ql-font-serif\">之前曾经简单介绍过 </span><a href=\"http://127.0.0.1:81/notes/article/5\" target=\"_blank\" class=\"ql-font-serif\">CSS中常用的一些选择器的使用</a><span class=\"ql-font-serif\">：</span><span class=\"ql-size-small ql-font-serif\"> </span></p><p><br></p><p><span class=\"ql-font-serif\">但使用过程中经常发生意料之外的效果，标签并未按照预期的效果显示，这很可能就是由于选择器的优先级引起的样式覆盖。</span></p><p><br></p><p><span class=\"ql-size-small\">如：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;p class=\"p\"&gt; This is p1 &lt;/p&gt; &lt;!-- p1 --&gt;\n&lt;p class=\"p\"&gt; This is p2 &lt;/p&gt; &lt;!-- p2 --&gt;\n&lt;p&gt; This is p3 &lt;/p&gt; &lt;!-- p3 --&gt;\n</pre><p><span class=\"ql-size-small\">文档中有一些类名为“p”的标签，一开始将它们的字体颜色设为 red：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">.p{ color:red }\n</pre><p><span class=\"ql-size-small\">后来又想将所有 p 标签的字体颜色都设置为 green：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">p{ color:green }\n</pre><p>\t<span class=\"ql-font-serif\">却发现在浏览器中，只有 p3 的字体颜色为 green，p1 及 p2 的字体颜色都为 red，这就是选择器的优先级引起的样式覆盖。</span></p><p><br></p><blockquote><strong>选择器的优先级</strong></blockquote><p><br></p><p>几种常用选择器的优先级比较：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div&gt;\n  &lt;p class=\"p\" id=\"p1\"&gt; This is a paragraph &lt;/p&gt;\n&lt;/div&gt;\n</pre><p>\t<span class=\"ql-font-serif\">默认字体颜色为：黑色。</span></p><p><span class=\"ql-size-small\">设置样式：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 标签选择器 */\np{ color:red }\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：red。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 后代选择器（可以理解为2个标签选择器） */\ndiv p{ color:blue }\t\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：blue。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 类选择器 */\n.p{ color:green }\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：green。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 后代选择器 + 类选择器 */\ndiv .p{ color:orange }\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：orange。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* id选择器 */\n#p1{ color:yellow }\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：yellow。</span></p><p><br></p><p>\t<span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">以上，可以清晰的看出几种常用选择器的优先级，即：id选择器 &gt; 类选择器 &gt; 标签选择器。</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">因此可以将这些选择器分别对应不同的 “位”，综合它们出现的次数用来计算 它们对应的样式的优先级：</span></p><p><br></p><p>\t\t\t\t<span class=\"ql-font-serif\">0 </span>\t\t\t\t\t\t\t\t<span class=\"ql-font-serif\">0</span>\t\t\t\t\t\t\t <span class=\"ql-font-serif\"> 0</span>\t\t\t\t</p><p>\t<span class=\"ql-font-serif\">id选择器出现次数\t类选择器出现次数\t标签选择器出现次数</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">把以上各种选择器出现次数 </span><u class=\"ql-font-serif\">拼接</u><span class=\"ql-font-serif\"> 成（不是简单的三个十进制数字相加）的数字最为样式最后的 权重值，比较这个值的大小即可得</span><span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">出</span><span class=\"ql-font-serif\">重复设置的样式中标签最后呈现的 样式。</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">在上例中\"p\"的权重值为\"0 0 1\"，\"div p\" 的 权重值为\"</span><span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">0 0 2</span><span class=\"ql-font-serif\">\"，\".p\" 的权重值为\"0 1 0\"，\"div .p\"的权重值为\"0 1 1\"，\"#p1\"的权重值为\"1 0 0\"，故 id选择器 \"#p1\" 中设置的样式为标签最后呈现的样式。</span></p><p><br></p><blockquote><strong>样式的权重</strong></blockquote><p><br></p><p>除以上几种选择器设置样式外，还可以在标签上定义内联（行内）样式：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div&gt; \n  &lt;p class=\"p\" id=\"p1\" style=\"color:pink\"&gt; This is a paragraph &lt;/p&gt;\n&lt;/div&gt;\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色为：pink。正常情况下，内联样式的权重高于外部设置样式。</span></p><p><br></p><p>继承父标签样式：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 设置父标签样式，子标签继承 */\ndiv{ color:purple }\n</pre><p>\t<span class=\"ql-font-serif\">在未单独设置 p 标签字体颜色时，其字体颜色为：purple。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">/* !important，更改 标签选择器中的设置 */\np{ color:red !important }\n</pre><p>\t<span class=\"ql-font-serif\">此时字体颜色变回：red。带有\"!important\"字样的样式权重高于其他方式设置的样式，当\"!important\"发生冲突时，则需要再次比较优先级。滥用\"!important\"将会导致样式混乱，应尽量避免使用。</span></p>','2019-02-20 12:37:23'),(4,'普通','CSS','HSIKE','标签类型、盒子模型及边界重叠','简单介绍HTML中根据元素（标签）在文档中的位置特性进行标签类型分类、标签的盒子模型和特殊情况下的标签的边界重叠现象及其解决方法。','盒子模型、标签类型、边界重叠','','<blockquote><strong class=\"ql-size-large\">HTML标签类型</strong></blockquote><p><br></p><p><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\">根据标签在文档中的位置特性可将元素（标签）分为三类：</span></p><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">\t</span><span style=\"color: rgb(68, 68, 68);\" class=\"ql-size-large\">1、</span><span style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\" class=\"ql-size-large\">块级元素（block）：可以设定宽高，默认宽度为父元素宽度；</span></p><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">\t</span><span style=\"color: rgb(68, 68, 68);\" class=\"ql-size-large\">2、</span><span style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\" class=\"ql-size-large\">行内元素（inline）：宽高由标签所包含的内容决定，设置无效，默认为0；</span></p><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">\t</span><span style=\"color: rgb(68, 68, 68);\" class=\"ql-size-large\">3、</span><span style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\" class=\"ql-size-large\">行级块元素（inline-block）：</span><span style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\">也称块级行元素，默认宽高由内容决定，但也可设置；</span></p><p><br></p><p><span class=\"ql-size-large\">块级元素在文档中会独占一整行（一行只能显示一个块级元素），即使其内容宽度小于标签宽度，而行内元素和行级块元素在内容 宽度小于标签宽度时，多个这种元素会并排在同一行显示。</span></p><p><br></p><p><span class=\"ql-size-large\">标签可以通过设定样式 { display: block / inline / inline-block } 转化为指定类型，将行级块元素转换为块级元素之后，其将独占一行但默认宽度不会变（有内容尺寸决定）；而将行内元素转换为块级元素后，其显示效果将与普通块级元素一致。</span></p><p><br></p><blockquote><strong class=\"ql-size-large\">标签盒子模型：</strong></blockquote><p><em class=\"ql-size-large\" style=\"color: rgb(136, 136, 136);\">HTML标签本身为一个容器，可被理解为一个盒子，在文档中具有分层结构 ，即盒子模型</em></p><p><br></p><p><span class=\"ql-size-large\">一、盒子分层，标签盒子从内到外可分为4层：</span></p><p><br></p><p><span class=\"ql-size-large\">\t</span><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68);\">1、内容 content：</span><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\">存放标签内容的区域，标签的宽高即 content 尺寸；</span></p><p><br></p><p><span style=\"color: rgb(68, 68, 68);\">\t</span><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\">2、内边距 padding：也叫内补白，在内容层与边框层之间增加隔离区域，控制内容层与边框层之间的距离（可以没有边框）；</span></p><p><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68);\"> </span></p><p><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68);\">\t3、边框 border：设置标签四周的边框 { border:边框粗细 显示类型 颜色 } （样式值顺序不固定） 某些标签自带边框，如：input、button等</span></p><p><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68);\"> 显示类型 ：solid 实线 dotted 圆点虚线 dashed 矩形虚线；</span></p><p><br></p><p><span class=\"ql-size-large\" style=\"color: rgb(68, 68, 68);\">\t4、外边距 margin：也叫外补白，在边框外增加隔离区域，用来控制当前标签与周围内容的间距。</span></p><p><br></p><p>\t<span class=\"ql-size-large\" style=\"background-color: rgb(255, 255, 255);\">设置</span><span class=\"ql-size-large\">行内元素的padding-top、padding-bottom时，元素盒子中存在这些样式，但显示效果不会发生变化（与文档中上下文行框重叠）；而行内元素的 margin-top、margin-bottom 则无法设置，这些样式不会存在与元素盒子中。</span></p><p><br></p><p><span class=\"ql-size-large\">二、盒子类型 box-sizing，盒子类型有2种：</span></p><p><br></p><p>\t<span class=\"ql-size-large\">1、IE盒模型 border-box：标签设定</span><span style=\"background-color: rgb(255, 255, 255);\">的</span> <span class=\"ql-size-large\">width / height 包含 border、padding 以及 content；标签同时设置了（或默认包含）width / height、border、padding，会压缩 content 的尺寸以保持其在文档中所占空间与 width / height 一致；</span></p><p>\t</p><p><span style=\"color: rgb(68, 68, 68);\"> </span>\t<span style=\"color: rgb(68, 68, 68);\" class=\"ql-size-large\">2、</span><span style=\"color: rgb(68, 68, 68); background-color: rgb(255, 255, 255);\">标准盒模型 content-box：</span><span style=\"background-color: rgb(255, 255, 255);\">width / height 仅包含 content；标签同时包含 width / height、border、padding时，其在文档中所占据的空间会比 width / height 大；</span></p><p><br></p><p><span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-size-small\">如：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;input type=\"text\" placeholder=\"输入框\"&gt;&lt;!-- input默认为标准盒模型 --&gt;\n&lt;button type=\"button\"&gt;按钮&lt;/button&gt;&lt;!-- button默认为IE盒模型 --&gt;\n</pre><p><span class=\"ql-size-small\">对2个标签设定同样的样式：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">input,button{\n  width:200px;\n  height:100px;\n}\n/* 2个标签设置的高度都为100px，但显示效果为 input 比 button 高一点点 */\n</pre><p><br></p><blockquote><strong class=\"ql-size-large\">边界重叠</strong></blockquote><p><br></p><p><span class=\"ql-size-large\">1、父子标签边界重叠：</span></p><p><br></p><p>\t<span class=\"ql-size-large\">父标签与子标签都在同一垂直方向上设定 margin 且父标签未在该方向上设定 padding 和 border 时，就会发生margin重叠现象，将取所设的 margin 值中较大的一个作为整体的 margin 。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"parent\"&gt;\n  &lt;div class=\"child\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</pre><p><span class=\"ql-size-small\">设置样式：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">.parent{\n  width:500px;\n  height:500px;\n  background-color:red;\n}\n.child{\n  width:200px;\n  height:200px;\n  background-color:green;\n  margin-top:100px;\n}\n</pre><p>\t<span class=\"ql-size-large\">child 的 margin-top 本应该让 child 在距离 parent 顶部 100px 的位置显示，而实际情况是 parent 和 child 的顶部重合在一起，child “拖着” parent 一起向下移动了100px，这是因为 parent 顶部未设置任何 “阻挡”，使得父子标签的顶部边界重合在了一起。若要实现预期的效果，可以设置 parent 的 border-top、padding-top 阻止边界重叠。</span></p><p><br></p><p><span class=\"ql-size-large\" style=\"background-color: rgb(255, 255, 255);\">2、兄弟相邻标签边界重叠：</span></p><p><br></p><p><span class=\"ql-size-large\">\t2个兄弟关系（相邻）的标签在垂直方向上设定的 margin 发生了相遇（一个 margin-bottom、一个 margin-top）且2个标签中间无内容或者没有高度的空标签时，将会发生边界重叠，重叠后取2个标签设定的 margin 值中较大的一个作为2个标签间的距离。</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"box1\"&gt;&lt;/div&gt;\n&lt;div class=\"box2\"&gt;&lt;/div&gt;\n</pre><p><span class=\"ql-size-small\">设置样式：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">.box1 {\n    background:red;\n    width:400px;\n    height:400px;\n    /* box1下边距50像素 */\n    margin-bottom:50px;\n}\n.box2 {\n    background:green;\n    width:300px;\n    height:300px;\n    /* box2上边距100像素 */\n    margin-top:100px;\n}\n/* box1下边距50px box2上边距100px，中间间距本应为150px，而实际发生边界重叠只取较大的100px */\n</pre><p>\t<span class=\"ql-size-large\">此时可以在2个标签中间增加一个 { height: 1px } 的空元素，或者将需要间隔的距离设置到一个标签的某个方向上以达到想要的显示效果。</span></p>','2019-02-20 14:29:09'),(5,'普通','CSS','HSIKE','CSS常用选择器的简单使用','简单介绍CSS中常用的一些选择器，如 标签选择器、类选择器、id选择器、属性选择器、子代与后代选择器、通配符选择器等的使用方法，及多种选择器组合使用。','选择器','','<blockquote><strong class=\"ql-size-large\">CSS选择器</strong></blockquote><p><em class=\"ql-size-large\" style=\"background-color: rgb(253, 252, 248); color: rgb(136, 136, 136);\">在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</em></p><p><br></p><blockquote><strong class=\"ql-size-large\" style=\"background-color: rgb(253, 252, 248);\">常用选择器</strong></blockquote><p><br></p><p><span class=\"ql-size-large\">1、标签选择器：使用标签名选择文档中元素</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">p{ color:red }\ndiv{ font-size: 20px }\n</pre><p>\t<span class=\"ql-font-serif ql-size-large\">把文档中所有 p 标签的文字颜色设为 red，所有 div 的字体大小设为 20px。</span></p><p><br></p><p><span class=\"ql-size-large\">2、类</span><span class=\"ql-size-large\" style=\"background-color: rgb(255, 255, 255);\">（class）</span><span class=\"ql-size-large\">选择器（.className）：通过</span><span class=\"ql-size-large\" style=\"background-color: rgb(255, 255, 255);\">标签设置的类名选择</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"red\"&gt;div with a className \"red\"&lt;/div&gt;\n&lt;p class=\"red\"&gt;p with a className \"red\"&lt;/p&gt;\n\n.red{ color:red }\n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">把文档中所有含有 “red” 类名的标签（与标签名称无关）中文字的颜色设为 red。</span></p><p><br></p><p><span class=\"ql-size-large\">3、id选择器（#id）：通过标签设置的 id 选择</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div id=\"div\"&gt;div with id \"div\"&lt;/div&gt;\n\n#div{ height:200px; background: red }\n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">将文档中 id 为 “div” 的标签高度设为 200px，背景颜色设为 red。</span></p><p>\t<span class=\"ql-size-large ql-font-serif\">注意：在 css 中，id 为唯一标识，因此不能为多个标签设置同一个 id。</span></p><p><br></p><p><span class=\"ql-size-large\">4、属性选择器（[propName=\"propValue\"]）：通过标签的属性选择</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div prop=\"pro\"&gt;test div&lt;/div&gt;\n&lt;p prop=\"pro\"&gt;test p&lt;/p&gt;\n\n[prop=\"pro\"]{ color:red }\n</pre><p>\t<span class=\"ql-font-serif ql-size-large\">div、p标签中的文字颜色将被设为 red。</span></p><p><span class=\"ql-font-serif ql-size-large\">注：class、id 也是标签的属性，因此</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">.className{ style } / #id{ style }   也可以写成  [class=\"className\"]{ style } / [id=\"id\"]{ style }\n</pre><p><br></p><p><span class=\"ql-size-large\">5、伪类选择器（:state）：选择处于某种状态的标签</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;input type=\"text\"&gt;\n&lt;button&gt;button&lt;/button&gt;\n\n:focus{ border:5px solid red }\n:active{ color:green }\n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">:focus 选择处于 “获得焦点” 状态的标签，:active 选择处于 “激活” 状态（被点击时）的标签，并为其设置样式，但一般只有表单元素及锚（a）标签才有这些状态。</span></p><p><br></p><p><span class=\"ql-size-large\">6、通配符选择器（*）：选择文档中所有的标签</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;p&gt; p &lt;/p&gt;\n&lt;a href=\"#\"&gt; a &lt;/a&gt;\n&lt;p class=\"p2\"&gt; another p &lt;/p&gt;\n\n*{ color:green }\n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">页面中所有标签的字体颜色都将被设置为 green。</span></p><p><br></p><p><span class=\"ql-size-large\">7、子代与后代选择器：选择嵌套标签中的子代或者后代标签</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"div\"&gt;\n  &lt;div class=\"test\"&gt;\n    &lt;div&gt; child div &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n        \n.div&gt;div{ border-top:5px solid red }\n.div div{ border-bottom:10px solid green } \n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">selector1&gt;selector2 选择 selector1 内的 selector2 标签，但 selector2 必须直接嵌套在 selector1 下，.div&gt;div 只会给 .test 设置顶部边框，而 .div div 将会为 .div 内部嵌套的所有 div设置底边框。</span></p><p><br></p><p><span class=\"ql-size-large\">8、选择器组合使用：使用多种选择器选择</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"txt\"&gt; test div &lt;/div&gt;\n&lt;p class=\"txt\"&gt; test p &lt;/div&gt;\n&lt;p class=\"txt\"&gt;\n  &lt;div class=\"txt&gt; another p &lt;/div&gt;\n&lt;/p&gt;\n&lt;div class=\"parent\"&gt;\n  &lt;div class=\"child\"&gt; child div &lt;/div&gt;\n  &lt;p class=\"child\"&gt; child p &lt;/p&gt;\n&lt;/div&gt;\n\n\np.txt{ border:5px solid red }\np .txt{ color:red }\n\n.parent p.child{ color: green }\n</pre><p>\t<span class=\"ql-size-large ql-font-serif\">p.txt （无空格）选择的是 类名中包含 “txt” 的 p 标签，而 p .txt （有空格）选择的是 嵌套 在 </span><span style=\"background-color: rgb(255, 255, 255);\">p 标签内且</span><span class=\"ql-font-serif ql-size-large\">类名中包含 “txt” 的后代标签</span></p><p><br></p><p><strong class=\"ql-size-large\">注意：使用css选择器为文档中标签设置样式时，要注意选择器的优先级引起的样式覆盖！</strong></p>','2019-02-20 14:29:11'),(6,'普通','JavaScript','HSIKE','JavaScript对象属性的特性','ES5定义只有内部采用的特性时，描述了JS中对象属性的一些特性，包括:属性的值——value、属性是否可写——writable、属性是否可枚举——enumerable、属性是否可配置——configurable，以及对这些特性的简单操作。','对象、对象属性特性','','<blockquote><strong>操作属性特征：Object.defineproperty()</strong></blockquote><p><br></p><p>虽然ES5中描述了属性的 [[value]]、[[writable]]、[[enumerable]]、[[configurable]] 这些特征，但由于<span style=\"background-color: rgb(255, 255, 255);\">定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问、修改它们（规范把他们放在了两对方括号中[[ ]]）。</span></p><p><br></p><p><span style=\"background-color: rgb(255, 255, 255);\">如果要修改属性默认的特性，就必要要使用ES5的Object.defineProperty( obj, propName, descriptor )方法。这个方法接收三个参数：obj 属性所在的对象、propName 需要修改的属性名、descriptor 描述符对象。其中，描述符对象的属性必须为四个特性中的一个或多个（配置多个属性时使用 Object.defineproperties()方法）。</span></p><p><br></p><blockquote><strong class=\"ql-size-large\">属性的值：value</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">可以理解为访问对象属性</em><em style=\"color: rgb(136, 136, 136); background-color: rgb(255, 255, 255);\">时</em><em style=\"color: rgb(136, 136, 136);\">返回</em><em style=\"color: rgb(136, 136, 136); background-color: rgb(255, 255, 255);\">的</em><em style=\"color: rgb(136, 136, 136);\">结果，默认为 undefined </em></p><p><br></p><p><span class=\"ql-size-small\">JS中可以像这样修改对象的属性：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">var example={ name:\'nameA\' };\nexample.name=\'nameB\';\n</pre><p><span class=\"ql-size-small\">也可以：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">Object.defineproperty( example, \'name\', { value: \'nameC\' });\nconsole.log(example.name); // \'nameC\'\n</pre><p><br></p><blockquote><strong>属性是否可写：writable</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">配置属性的值是否可以被修改，默认为 true</em></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Object.defineproperty( example, \'name\', { writable:false });\n// 此时 example 的 name 属性将不可写 运行以下：\nexample.name=\'nameD\';\nconsole.log( example.name ); // \'nameC\'\n// 修改 example.name 的操作被忽略，但在严格模式下将会报错\n</pre><p><br></p><blockquote><strong>属性是否可枚举：enumerable</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">配置属性是否可枚举（一般用于 for in 循环枚举对象属性，或者 Object.keys( obj ) 以数组形式输出对象的可枚举属性），默认为 true</em></p><p><br></p><p><span class=\"ql-size-small\">枚举 example的属性：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log( Object.keys( example ) ); // [\'name\']\n</pre><p><span class=\"ql-size-small\">将 example.name 设置为 不可枚举：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">Object.defineproperty( example, \'name\', { enumerable:false } );\nconsole.log( Object.keys( example ) ); // []\n</pre><p><br></p><blockquote><strong>属性是否可配置：configurable</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">设置属性是否可以被修改，默认为 true</em></p><p><br></p><p><span class=\"ql-size-small\" style=\"color: rgb(68, 68, 68);\">正常情况下，我们可以通过 delete 来删除对象的某个属性：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">delete example.name;\nconsole.log( example ); // {}\n</pre><p><span class=\"ql-size-small\">另一个例子：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">var example2={ name: \'name2\' };\n// 将其 name 属性设置为不可配置：\nObject.defineproperty( example2, \'name\', { configurable:false });\n</pre><p><span class=\"ql-size-small\">尝试删除 example2.name:</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">delete example2.name;\nconsole.log( example2 ); // { name:\'name2\' }\n// 可以看到 name 属性并未被删除，在严格模式下执行该代码将导致报错\n</pre><p><span class=\"ql-size-small\">尝试将其改回为可配置：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">try{ Object.defineproperty( example2, \'name\', { configurable:true } )\ncatch(e){ console.log(e) } // 捕获异常：Cannot redefine property: name\n</pre><p> \t该操作为 <u style=\"color: rgb(92, 0, 0);\">不可逆</u><span style=\"color: rgb(68, 68, 68);\"> ，将属性的 [[configurable]] 设置为 false 后，企图再次将其设置为 true 将导致报错（这里使用 try catch 语句捕获错误，避免报错导致后面代码无法执行）</span></p><p><br></p><p>\t但是，尽管此时 example2 的 name 属性不可配置，但当其 writable 属性为 true （可写）时，依然可以对其 name 属性进行修改：</p><pre class=\"ql-syntax\" spellcheck=\"false\">example.name=\'name3\';\nconsole.log( example.name ); // \'name3\'\n</pre><p><br></p><p>\t在ES6之前，JS中没有 “常量” 的概念，但是通过设置属性的 configurable:false 和 writable:false 可以定义一个 属性不可变、不可删除的 “变量”。</p>','2019-02-20 14:29:14'),(7,'普通','JavaScript','HSIKE','变量的作用域、变量提升及函数提升','在JS中，变量作为存储信息的容器，可以存储任何类型的数据。变量的类型与其作用域、变量提升现象以及函数提升现象。','变量、作用域、函数','','<blockquote><strong>变量类型与作用域</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">变量的作用域为变量可被使用的范围，包括 全局作用域 和 局部作用域（函数作用域），对应的变量称为 全局变量 和 局部变量</em></p><p><br></p><p>1、全局变量：在 全局作用域 下定义的变量，可以在任何位置使用</p><pre class=\"ql-syntax\" spellcheck=\"false\">var gVar=\'a global variable\'; // 定义一个全局变量\n// 可以在函数外使用\nconsole.log(gVar); // \'a global variable\'\n// 也可以在函数内使用\n!function fa(){\n  console.log(gVar); // \'a global variable\'\n}();\n</pre><p><br></p><p>2、局部变量：在 函数内部（局部作用域） 定义的变量，只有当前函数内部能够使用。</p><pre class=\"ql-syntax\" spellcheck=\"false\">!function fb(){\n  var fVar=\'fVar\';\n  console.log(fVar); // \'fVar\'\n}()\n// 尝试在函数外访问 fVar时，会导致报错\nconsole.log(fVar); // fVar is not defined\n</pre><p>\t<span class=\"ql-font-serif\">要想在函数外访问局部变量时，需要使用到 </span><a href=\"http://127.0.0.1:81/notes/article/8\" target=\"_blank\" class=\"ql-font-serif\">闭包 </a></p><p><br></p><p>特殊情况：</p><pre class=\"ql-syntax\" spellcheck=\"false\">!function fc(){\n  var gVar=\'gVar\';\n  console.log(gVar); // \'gVar\'\n  gVar2=\'another global variable\';\n}()\nconsole.log(gVar); // \'a global variable\'\nconsole.log(gVar2); // \'another global variable\'\n</pre><p>\t<span class=\"ql-font-serif\">可以在函数内部定义与函数外部同名的 局部变量，二者互不影响，函数内部优先使用 局部变量（涉及 </span><a href=\"http://127.0.0.1:81/notes/article/9\" target=\"_blank\" class=\"ql-font-serif\">变量的作用域链</a><span class=\"ql-font-serif\">）</span></p><p><span class=\"ql-font-serif\">在函数内部定义变量时，若省略 \"var\" 关键字，将定义一个全局变量，但在严格模式下会导致报错。</span></p><p><br></p><blockquote><strong>变量提升</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">在JS中，变量的声明会自动提升到其作用域的顶部</em></p><p><br></p><p>也就是说，在JS中可以 \"先使用再定义变量\" 而不会导致报错：</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(test); // undefined\nvar test=\'test variable\';\n</pre><p>\t<span class=\"ql-font-serif\">虽然这没有导致报错，但 \"先使用\" 却不能获取到 \"后定义\" 的变量的值，这是因为 变量提升 仅仅是把 \"</span><span class=\"ql-font-serif\" style=\"background-color: rgb(255, 255, 255);\">变量的声明</span><span class=\"ql-font-serif\">\" 提升到了其作用域顶部，但其 初始化赋值 却被保留在了原来的位置，等同于：</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">var test;\nconsole.log(test);\ntest=\'test variable\';\n</pre><p>\t<span class=\"ql-font-serif\">注意：先使用后定义变量 的方式在严格模式下将会导致报错，应当避免使用。</span></p><p><br></p><blockquote><strong>函数提升</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">与变量提升类似，函数声明也会被提升至其作用域顶部</em></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">fun(); // \'Hello World\'\nfunction fun(){\n  console.log(\'Hello World\');\n}\n</pre><p><span style=\"background-color: rgb(255, 255, 255);\">与变量提升不同的是，函数提升后函数可以正常执行</span></p><p>\t<span class=\"ql-font-serif\">注意：函数提升仅存在于 </span><u class=\"ql-font-serif\">以 \"function\" 关键字声明的函数</u><span class=\"ql-font-serif\"> 中</span></p><pre class=\"ql-syntax\" spellcheck=\"false\">fun2(); // undefined\nvar fun2=function(){\n\tconsole.log(\'Hello Again\');\n}\n</pre><p>\t<span class=\"ql-font-serif\">输出 undefined 是因为 fun2 发生了变量提升。同样，也不推荐 \"先使用后定义\" 的方式声明函数。</span></p>','2019-02-20 14:29:30'),(8,'推荐','JavaScript','HSIKE','JavaScript中的闭包','在JS中，由于作用域的限制，函数外部无法访问函数内部定义的局部变量；而在有的情况下，又不得不这么做，此时就需要使用闭包。','函数、变量、作用域','','<blockquote><strong>闭包</strong></blockquote><p><em style=\"background-color: rgb(255, 255, 255); color: rgb(136, 136, 136);\">闭包就是能够读取其他函数内局部变量的函数</em></p><p><br></p><p>\t<span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">在JavaScript中，只有在函数的内部才能读取 函数内定义的</span><span style=\"background-color: rgb(255, 255, 255); color: rgb(68, 68, 68);\" class=\"ql-font-serif\">局部变量</span><span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">，所以闭包可以理解成 \"定义在一个</span><a href=\"https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255); color: rgb(68, 68, 68);\" class=\"ql-font-serif\">函</a><span style=\"background-color: rgb(255, 255, 255); color: rgb(68, 68, 68);\" class=\"ql-font-serif\">数</span><span style=\"background-color: rgb(255, 255, 255);\" class=\"ql-font-serif\">内部的函数\"。闭包是将函数内部和函数外部连接起来的桥梁。</span></p><p><br></p><p>引用《JavaScript权威指南》关于闭包一节中的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var scope=\'global scope\'; // 创建一个全局变量 scope\nfunction checkScope(){\n  var scope=\'local scope\'; // 在 checkScope 函数内创建一个局部变量scope\n  function f(){ return scope } // 创建一个函数，返回 checkScope 函数内的局部变量scope\n  return f(); // 返回上面创建的函数的运行结果\n}\nconsole.log(checkScope()); // \'local scope\'\n</pre><p>\t<span class=\"ql-font-serif\">也就是说，通过 checkScope 函数内部定义的 f 函数，实现了在 checkScope 函数外部访问其局部变量 scope，这个函数 f 就是一个 闭包。</span></p><p><br></p><blockquote><strong>作用域链补充</strong></blockquote><p><br></p><p>将上面的例子稍作修改：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var scope=\'global scope\'; \nfunction checkScope(){\n  var scope=\'local scope\'; \n  function f(){ return scope } \n  return f; // 返回上面创建的函数\n}\nfunction returnScope(){ return scope }\nconsole.log(returnScope()); // \'global scope\'\nconsole.log(checkScope()()); // \'local scope\'\n</pre><p>\t<span class=\"ql-font-serif\">声明并调用一个全局函数，并让其返回其作用域链上查找到的 scope，返回值为全局的 scope；</span></p><p>\t</p><p>\t<span class=\"ql-font-serif\">将 checkScope 函数的返回值修改为在其内部定义的函数 f 并在函数外调用，结果输出的仍然是 checkScope 函数的内的局部变量 scope。</span></p><p>\t</p><p>\t<span class=\"ql-font-serif\">虽然2个函数（returnScope 和 f）都是在全局环境下运行，但它们的作用域链却不一样。这导致它们在作用域链上查找到的 scope 的值不一样，</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">returnScope 函数执行时，函数内部访问了 scope，但未在当前函数作用域内找到变量 scope 的定义，于是沿着作用域链向上层查找，即全局作用域，返回全局的 scope；而 f 函数在执行时，在 f 内未找到 scope 的定义，于是前往上层的 checkScope 函数的作用域查找，而不是像 returnScope 函数执行时一样前往 全局作用域 查找。</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">也就是说：访问一个局部变量且未在当前局部作用域内找到该变量的定义并向上层作用域查找时，并不是去 运行当前环境的环境中寻找，而是去 创建当前环境的环境 中寻找直到找到或者JS引擎抛出错误。</span></p><p>\t</p>','2019-02-20 14:24:55'),(9,'推荐','JavaScript','HSIKE','执行环境及变量的作用域链','作用域有 全局作用域 和 局部作用域 之分，它们分别对应 全局变量 和 局部变量，全局变量和局部变量的的访问权限（可使用范围），就是由 作用域链 决定的。','变量、函数、作用域','','<blockquote><strong>执行环境</strong></blockquote><p><em style=\"color: rgb(136, 136, 136); background-color: rgb(255, 255, 255);\">执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之对应的变量对象，保存着该环境中定义的所有变量和函数。</em></p><p><br></p><p>\t<span class=\"ql-font-serif\" style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">执行环境有全局执行环境（也称全局环境）和函数执行环境之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们运行浏览器的时候会创建全局的执行环境，在调用函数时，会创建函数执行环境</span><span class=\"ql-font-serif\" style=\"color: rgb(34, 34, 34); background-color: rgb(255, 255, 255);\">。</span></p><p><br></p><blockquote><strong>作用域链</strong></blockquote><p><a href=\"http://127.0.0.1:81/notes/article/7\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255); color: rgb(0, 102, 204);\"><em>作用域</em></a><em style=\"background-color: rgb(255, 255, 255); color: rgb(136, 136, 136);\">链 是函数被创建的作用域中对象的集合,可以保证对执行环境有权访问的所有变量和函数的有序访问。</em></p><p><br></p><p>\t<span class=\"ql-font-serif\" style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">全局作用域和局部作用域中变量的访问权限，就是是由作用域链决定的。每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。</span></p><p><br></p><p>\t<span class=\"ql-font-serif\" style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">作用域链的最底层始终是当前执行的代码所在环境的变量对象（如果该环境是函数，则将其活动对象作为变量对象），下一个变量对象来自于 包含当前运行环境的环境，以此类推依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。</span></p><p><img src=\"data:image/gif;base64,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\"></p><p><span class=\"ql-font-serif\">\t</span></p><p>\t<span class=\"ql-font-serif\" style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">标识符（变量）解析是沿着作用域搜索的过程。这个过程自作用域链底层向上逐层搜索，直到找到标识符（找不到，JS引擎就会抛出错误）。</span></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">var globalNum=0;\n!function fnA(){\n  var aNum=1;\n  !function fnB(){\n    var bNum=2;\n    console.log(\'fnB中访问bNum:\',bNum); // 2\n    console.log(\'fnB中访问aNum:\',aNum); // 1\n    console.log(\'fnB中访问globalNum:\',globalNum);\n  }()\n}()\nconsole.log(\'全局环境访问globalNum\',globalNum); // 0\nconsole.log(\'全局环境访问aNum:\',aNum); // error: aNum is not defined\nconsole.log(\'全局环境访问bNum:\',bNum); // error: bNum is not defined\n\n</pre><p>\t<span class=\"ql-font-serif\">上面这个例子中，在 fnB 中访问 bNum时，在当前执行环境的</span><span class=\"ql-font-serif\" style=\"background-color: rgb(255, 255, 255);\">变量对象</span><span class=\"ql-font-serif\">内找到了 bNum 后将其输出；访问 aNum 时未在当前环境的变量对象内找到 aNum，故向上在包含当前执行环境的的环境即 fnA 的环境的变量对象内查找 aNum 并将其输出，访问 globalNum 时则是一直向上直到全局环境才找到。</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">全局环境中访问 globalNum 时，在当前（全局）环境</span><span style=\"background-color: rgb(255, 255, 255);\">的</span><span class=\"ql-font-serif\">变量对象内找到并将其输出，但访问 aNum 和 bNum 时，未在当前环境的变量对象中找到这2个变量，但其已经处于作用域链的最顶层，无法再向上查找，JS引擎抛出错误。</span></p>','2019-02-20 12:40:29'),(10,'推荐','JavaScript','HSIKE','ES5新增数组方法','ES5中针对数组新增了9个方法，包括2个索引方法、5个迭代方法、2个归并方法用来遍历、映射、过滤、检测、简化和搜索数组。它们都不会修改原数组。','数组、迭代','','<blockquote><strong>索引方法</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">用于查找指定元素在数组中的位置（索引）</em></p><p><br></p><p>1、indexOf(ele, start) ：从给定的索引start（可选，不合法时为 0，缺省时从数组头部开始）开始，查找 ele 在目标数组中第一次出现时的索引，不存在则返回 -1</p><pre class=\"ql-syntax\" spellcheck=\"false\">var arr=[1,2,3,4,3,2,1];\ncosole.log(arr.indexOf(3)); // 2\nconsole.log(arr.indexOf(3,4)); // -1\n</pre><p><br></p><p>2、lastIndexOf(ele, start)：同 indexOf()，只是从数组的末尾开始向前查找</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr.lastIndexOf(3)); // 4\nconsole.log(arr.lastIndexOf(3,3)); // 2\n</pre><p>\t<span class=\"ql-font-serif\">注意：这2中方法查找数组元素时，使用的是 全等 判断（===）。</span></p><p><br></p><blockquote><strong>迭代方法</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">迭代方法共有5个，这些方法都接收2个参数，第一个参数为一个函数，这个函数接收3个参数分别为数组当前元素、当前元素的索引、数组本身；第二个参数可选，用来改变第一个参数的作用域即函数中 this 的指向。</em></p><p><br></p><p>1、forEach(fn, o)：从头至尾遍历数组对数组中每一个元素调用给定的函数 fn</p><pre class=\"ql-syntax\" spellcheck=\"false\">arr.forEach(function(value){ // 可以当不需要使用到元素的索引、数组本身时，fn的第二、三个参数可以省略\n  console.log(value) \n}); // 遍历数组arr，使其每一项的值增加1\nconsole.log(arr); // 1,2,3,4,3,2,1\n</pre><p>\t<span class=\"ql-font-serif\">forEach() 方法</span><span class=\"ql-font-serif\" style=\"font-size: 1rem; background-color: rgb(255, 255, 255);\">在</span><span class=\"ql-font-serif\">完整地遍历完数组的每一项之前不会停下（除非遇到错误）。</span></p><p><br></p><p>2、map(fn, o)：遍历数组，为数组的每一项调用函数 fn，返回由 fn 处理结果组成的新数组</p><pre class=\"ql-syntax\" spellcheck=\"false\">let map=arr.map(function(value){\n  return value+1\n}); // 对数组的每一项 +1 并返回\nconsole.log(map); // [2,3,4,5,4,3,2]\n</pre><p>\t<span class=\"ql-font-serif\">同样地，map() 也会完整地遍历数组，但它要求传入的函数 fn 有一个返回值</span></p><p><br></p><p>3、filter(fn, o)：遍历数组，返回 会使 函数fn 返回 true 的元素组成的新数组</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr.filter(function(value){\n  return value &gt; 2; // 对于数组的每一项，返回其是否大于2的比较结果\n})); // [3,4]\n</pre><p>\t<span class=\"ql-font-serif\">filter() 要求 fn 的返回值为 Boolean 值</span></p><p><br></p><p>4、every(fn, o)：遍历数组，当数组的每一个元素都使 fn 返回 true 时，返回 true，否则返回 false</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr.every(function(value){\n  return value &lt; 5; // 对数组的每一项判断其是否小于5\n})); // false\n</pre><p><br></p><p>5、some(fn, o)：遍历数组，只要数组中存在元素使 fn 返回 true 就返回 true，否则返回false</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr.some(function(value){\n  return value &gt; 4; // 对数组的每一项判断其是否小于5\n})); // true\n</pre><p>\t<span class=\"ql-font-serif\">every() 和 some() 方法都要求传入的函数 fn 返回值为 Boolean值</span></p><p><br></p><blockquote><strong>归并方法</strong></blockquote><p><em style=\"color: rgb(136, 136, 136);\">迭代数组中的所有元素，然后生成一个最终的返回值。接收2个参数，为数组元素调用的函数 fn 和 迭代的初始值；其中 fn必须有返回值，第二个参数可选，缺省时为数组的第一项。</em></p><p><br></p><p>1、reduce(fn, init) ：从头至尾遍历数组，为数组调用 fn </p><pre class=\"ql-syntax\" spellcheck=\"false\">console.log(arr.reduce(function(value1,value2){\n  return value1 + value2; // 将数组中的每一项相加\n},0)); // 16\n</pre><p>2、<span style=\"background-color: rgb(255, 255, 255);\">reduceRight(fn, init)：和 reduce() 一样，但是从数组的末尾开始遍历</span></p><p><br></p><p>\t<span class=\"ql-font-serif\">reduce() 和 reduceRight() 中每次对数组元素进行遍历时，都会将传入的初始值 init 作为 fn 的第一个参数 value1 传入 fn 中，并在 fn 执行完后将 fn 的返回值作为下一次遍历的初始值（init）并传入下一次执行 fn 时的 value1 中。</span></p>','2019-02-20 15:52:39');

#
# Structure for table "comments"
#

DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `Id` int(11) NOT NULL auto_increment,
  `pid` varchar(255) default NULL COMMENT '所属文章的Id',
  `userName` varchar(255) default NULL COMMENT '用户名',
  `email` varchar(255) default NULL COMMENT '邮箱',
  `headPic` varchar(255) default NULL COMMENT '头像',
  `content` longtext COMMENT '内容',
  `time` timestamp NULL default NULL COMMENT '发布时间',
  PRIMARY KEY  (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='评论';

#
# Data for table "comments"
#


#
# Structure for table "navs"
#

DROP TABLE IF EXISTS `navs`;
CREATE TABLE `navs` (
  `Id` int(11) NOT NULL auto_increment,
  `navName` varchar(255) default NULL COMMENT '类名',
  `value` varchar(255) default NULL COMMENT '索引关键字',
  `pid` varchar(255) default NULL COMMENT '父类的Id，顶层为0',
  PRIMARY KEY  (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT='文章分类导航';

#
# Data for table "navs"
#

INSERT INTO `navs` VALUES (1,'CSS','CSS','0'),(2,'HTML','HTML','0'),(3,'JavaScript','JavaScript','0'),(4,'框架','框架','0'),(5,'Vue','Vue','4'),(6,'React','React','4'),(7,'Angular','Angular','4'),(8,'类库','类库','0'),(9,'BootStrap','Bootstrap','8'),(10,'jQuery','jQuery','8'),(11,'后端','后端','0'),(12,'Node','Node','11'),(13,'MySQL','MySQL','11');

#
# Structure for table "users"
#

DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `Id` int(11) NOT NULL auto_increment,
  `userName` varchar(255) default NULL COMMENT '用户名',
  `password` varchar(255) default NULL COMMENT '密码',
  `email` varchar(255) default NULL COMMENT '邮箱',
  `headPic` varchar(255) default NULL COMMENT '头像路径',
  `type` varchar(255) default NULL COMMENT '类型(普通？管理员？)',
  `state` varchar(255) default NULL COMMENT '状态(禁言？)',
  `time` timestamp NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP COMMENT '资料更新时间',
  PRIMARY KEY  (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

#
# Data for table "users"
#

INSERT INTO `users` VALUES (1,'HSIKE','HS123.hsike..','893008093@qq.com','http://127.0.0.1:3000/img/avatars/1550028891612.png','admin','blocked','2019-02-19 09:32:07');

#
# Structure for table "website"
#

DROP TABLE IF EXISTS `website`;
CREATE TABLE `website` (
  `Id` int(11) NOT NULL auto_increment,
  `title` varchar(255) default NULL COMMENT '网站标题',
  `keywords` varchar(255) default NULL COMMENT '网站关键字',
  `description` longtext COMMENT '网站描述',
  `logo` varchar(255) default NULL COMMENT '网站logo',
  `icon` varchar(255) default NULL COMMENT '网站图标',
  `icp` varchar(255) default NULL COMMENT '备案信息',
  PRIMARY KEY  (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站基本信息';

#
# Data for table "website"
#

